Overview
Model Context Protocol (MCP) is revolutionizing how AI agents interact with external systems. Think of MCP tools as the new APIs for LLMs - instead of agents making raw HTTP calls, they use standardized, type-safe tools that understand context and provide structured interactions.

What is Model Context Protocol (MCP)?
Model Context Protocol is an open standard that enables seamless integration between AI assistants and external tools, data sources, and services. It provides a unified way for Large Language Models to interact with the world beyond their training data.

The Problem MCP Solves
Before MCP, AI agents faced several challenges:

Fragmented Integrations: Each service required custom integration code
No Standardization: Every API had different patterns and authentication methods
Limited Context: Agents couldn't maintain context across different tool interactions
Type Safety Issues: No guarantee that tool calls would work correctly
MCP as the New API Standard
MCP tools are fundamentally different from traditional APIs:

typescript

Copy
// ‚ùå Traditional API: Raw HTTP calls, no context, error-prone
const response = await fetch('https://api.weather.com/current', {
  headers: { 'Authorization': `Bearer ${token}` },
  method: 'GET'
});
const weather = await response.json(); // Hope it works!

// ‚úÖ MCP Tool: Informs AI models how to get the weather, and provides logic to do so!
mcpServer.tool(
  'get_weater',
  'Get the current weather in a given city',
  {
    city: z.string().describe('City'),
  },       
  async ({ city }: { 
    city: string; 
  }) => {
    // Business logic for getting weather
  }
)
Core MCP Concepts
Tools vs Resources vs Prompts
MCP provides three main interaction patterns:

üîß Tools - Functions that agents can execute

typescript

Copy
// Example: File operations, API calls, calculations
await mcp.call('create-file', { path: '/docs/readme.md', content: 'Hello World' });
üìö Resources - Data sources that agents can read

typescript

Copy
// Example: Files, databases, documentation
const content = await mcp.read('file:///workspace/config.json');
üí≠ Prompts - Pre-defined prompt templates

typescript

Copy
// Example: Code review, analysis templates  
const prompt = await mcp.getPrompt('code-review', { language: 'typescript' });
Why MCP Tools Are Revolutionary
1. Context Awareness
Traditional APIs are stateless. MCP tools understand the conversation context and maintain state across interactions.

2. Type Safety
Every MCP tool comes with schema validation, ensuring agents call tools correctly every time.

3. Composability
MCP tools can work together seamlessly, enabling complex workflows through simple tool chaining.

4. Universal Standard
One protocol works across all AI models and platforms - no vendor lock-in.

MCP Servers
MCP Servers expose tools, resources, and prompts to AI agents. They act as bridges between the standardized MCP protocol and specific services or data sources.

MCP Clients
MCP Clients (like our TypeScript Agent Framework Toolbox) consume MCP servers and make their capabilities available to AI models.

Benefits of MCP
For Developers
Rapid Development: Build tools once, use everywhere
Type Safety: Full TypeScript support with compile-time validation
Ecosystem: Leverage existing MCP servers from the community
Testability: Tools are easily unit tested and debugged
For AI Agents
Reliability: Structured interactions with guaranteed schemas
Capability: Access to unlimited external functionality
Context: Maintain state and context across tool calls
Composability: Chain tools together for complex operations
The MCP Ecosystem
The MCP ecosystem is rapidly growing with servers for:

Development Tools: Git, Docker, package managers
Cloud Services: AWS, Azure, Google Cloud
Databases: PostgreSQL, MongoDB, Redis
APIs: Slack, GitHub, Stripe, OpenAI
File Systems: Local files, cloud storage
Monitoring: Metrics, logs, alerts
Getting Started
Ready to build your first MCP server? Our Getting Started guide walks you through creating a complete MCP server with real tools, from setup to deployment.

Next Steps
Getting Started - Build your first MCP server
Agent Framework - Integrate MCP tools with AI agents
Platform Services - Backend services for MCP servers
MCP is transforming how AI agents interact with the world. Join the revolution and build the tools that will power the next generation of AI applications.

Previous
Overview
Next


Getting Started
Ready to build your first MCP server? This guide walks you through creating a complete Model Context Protocol server using our TypeScript template. You'll learn the core concepts while building real tools that AI agents can use.

What We'll Build
By the end of this guide, you'll have a fully functional MCP server with:

üß∞ Custom Tools: Functions that AI agents can call
üìö Resources: Data sources agents can read
üí≠ Prompts: Reusable prompt templates
üåê WebSocket & SSE Support: Real-time communication protocols
üöÄ Cloudflare Deployment: Production-ready hosting
Quick Setup
1. Initialize Your Project
bash

Copy
# Install the nullshot CLI globally (use pnpm to avoid permission issues)
pnpm add -g @nullshot/cli

# Create a new MCP server from template
nullshot create mcp
choose your project name: eg: my-mcp-server

cd my-mcp-server (this is where your project is)

# Initialize configuration and add npm scripts
nullshot init
This creates:

mcp.json - MCP server configuration
Adds dev:nullshot script to package.json
Adds postinstall script for automatic dependency management
Optionally configures cf-typegen for Cloudflare Workers types
2. Configure Your Services
Edit the generated mcp.json with the TypeScript MCP template:

json

Copy
{
  "servers": {
    "mcp-template": {
      "source": "https://github.com/null-shot/typescript-mcp-template.git#main",
      "command": "npm run dev"
    }
  }
}
3. Install Dependencies
bash

Copy
# Install all configured servers and dependencies
nullshot install
This will:

Install packages from GitHub repositories

Detect and extract Cloudflare Workers configurations

Run D1 database migrations if present

Generate service bindings in your wrangler.jsonc

Generate Cloudflare Workers types with cf-typegen

5. Start Development
bash

Copy
# Run all services in development mode
nullshot dev
6. Start MCP Inspector
bash

Copy
# Start the MCP Inspector in a new terminal
pnpm dev
The MCP Inspector will automatically open at http://localhost:6274 and your MCP server will run on http://localhost:8787. The Inspector should automatically connect using SSE transport at http://localhost:8787/sse.

Understanding the Architecture
Project Structure
code

Copy
my-mcp-server/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts      # Main entry point and routing
‚îÇ   ‚îú‚îÄ‚îÄ server.ts     # MCP server implementation
‚îÇ   ‚îú‚îÄ‚îÄ tools.ts      # Tool definitions
‚îÇ   ‚îú‚îÄ‚îÄ resources.ts  # Resource definitions
‚îÇ   ‚îî‚îÄ‚îÄ prompts.ts    # Prompt templates
‚îú‚îÄ‚îÄ wrangler.jsonc    # Cloudflare configuration
‚îî‚îÄ‚îÄ package.json      # Dependencies and scripts
Core Implementation
1. Main Entry Point (src/index.ts)
The entry point handles routing and protocol negotiation:

typescript

Copy
// Worker entrypoint for handling incoming requests
export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    const url = new URL(request.url);
    const sessionIdStr = url.searchParams.get('sessionId')
    const id = sessionIdStr
        ? env.MCP_SERVER.idFromString(sessionIdStr)
        : env.MCP_SERVER.newUniqueId();

    console.log(`Fetching sessionId: ${sessionIdStr} with id: ${id}`);
    
    url.searchParams.set('sessionId', id.toString());

    return env.MCP_SERVER.get(id).fetch(new Request(
        url.toString(),
        request
    ));
  }
};
The above forwards requets to a dedicated MCP server which supports the following with zero configuration:

Key Features:

Health Check: Simple endpoint to verify server status
WebSocket Support: Real-time bidirectional communication
SSE Support: Server-sent events for streaming responses
Durable Objects: Persistent, stateful server instances
2. MCP Server Implementation (src/server.ts)
The server extends our MCP framework and configures tools, resources, and prompts:

typescript

Copy
import { McpHonoServerDO } from "@nullshot/mcp-framework";
import { setupServerTools } from "./tools";
import { setupServerResources } from "./resources";
import { setupServerPrompts } from "./prompts";

export class ExampleMcpServer extends McpHonoServerDO<Env> {
  // Required: Define server metadata
  getImplementation(): Implementation {
    return {
      name: 'ExampleMcpServer',
      version: '1.0.0',
    };
  }

  // Configure all server capabilities
  configureServer(server: McpServer): void {
    // Add tools (functions agents can call)
    setupServerTools(server);
    
    // Add resources (data agents can read)
    setupServerResources(server);
    
    // Add prompts (templates agents can use)
    setupServerPrompts(server);
  }
}
Key Concepts:

Implementation: Metadata about your MCP server
Tools: Functions that agents can execute
Resources: Data sources agents can access
Prompts: Reusable prompt templates
3. Building Your First Tool (src/tools.ts)
Tools are functions that AI agents can call. Here's a simple "Hello World" example:

typescript

Copy
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

export function setupServerTools(server: McpServer) {
  // Hello World Tool - A simple greeting function
  server.tool(
    'hello-world',                    // Tool name
    'Say hello to someone',           // Description for the AI
    {                                // Parameters schema using Zod
      name: z.string().describe('Name of the person to greet'),
      language: z.enum(['english', 'spanish', 'french']).optional().describe('Language for greeting')
    },
    async ({ name, language = 'english' }) => {
      // Tool implementation
      const greetings = {
        english: `Hello, ${name}! üëã`,
        spanish: `¬°Hola, ${name}! üëã`,
        french: `Bonjour, ${name}! üëã`
      };

      const greeting = greetings[language] || greetings.english;

      return {
        content: [
          {
            type: "text",
            text: greeting
          }
        ]
      };
    }
  );

  // Advanced Tool - Get current time with formatting
  server.tool(
    'get-current-time',
    'Get the current date and time with optional formatting',
    {
      format: z.enum(['iso', 'human', 'timestamp']).optional().describe('Output format'),
      timezone: z.string().optional().describe('Timezone (e.g., America/New_York)')
    },
    async ({ format = 'human', timezone = 'UTC' }) => {
      const now = new Date();
      
      let timeString: string;
      switch (format) {
        case 'iso':
          timeString = now.toISOString();
          break;
        case 'timestamp':
          timeString = now.getTime().toString();
          break;
        case 'human':
        default:
          timeString = now.toLocaleString('en-US', { 
            timeZone: timezone,
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          });
      }

      return {
        content: [
          {
            type: "text",
            text: `Current time: ${timeString} (${timezone})`
          }
        ]
      };
    }
  );

  // Utility Tool - Generate random number
  server.tool(
    'random-number',
    'Generate a random number within a specified range',
    {
      min: z.number().describe('Minimum value (inclusive)'),
      max: z.number().describe('Maximum value (inclusive)'),
      decimals: z.number().optional().describe('Number of decimal places')
    },
    async ({ min, max, decimals = 0 }) => {
      if (min > max) {
        throw new Error('Minimum value cannot be greater than maximum value');
      }

      const random = Math.random() * (max - min) + min;
      const result = decimals > 0 ? Number(random.toFixed(decimals)) : Math.floor(random);

      return {
        content: [
          {
            type: "text",
            text: `Random number: ${result}`
          }
        ]
      };
    }
  );
}
Tool Development Best Practices:

Clear Naming: Use descriptive, hyphenated names
Rich Descriptions: Help AI understand when to use your tool
Schema Validation: Use Zod for type-safe parameter validation
Error Handling: Provide helpful error messages
Structured Output: Return consistent response formats
4. Adding Resources (src/resources.ts)
Resources are data sources that agents can read:

typescript

Copy
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

export function setupServerResources(server: McpServer) {
  // Simple text resource
  server.resource(
    'greeting-templates',
    'resource://greeting-templates',
    async (uri: URL) => {
      const templates = {
        formal: "Good day, {name}. I hope this message finds you well.",
        casual: "Hey {name}! What's up?",
        business: "Dear {name}, Thank you for your time.",
        friendly: "Hi there {name}! Hope you're having a great day!"
      };

      return {
        contents: [
          {
            uri: uri.href,
            mimeType: "application/json",
            text: JSON.stringify(templates, null, 2)
          }
        ]
      };
    }
  );

  // Dynamic resource with parameters
  server.resource(
    'system-info',
    'resource://system-info/{category}',
    async (uri: URL) => {
      const category = uri.pathname.split('/').pop();
      
      const systemInfo = {
        server: {
          name: "ExampleMcpServer",
          version: "1.0.0",
          uptime: process.uptime(),
          timestamp: new Date().toISOString()
        },
        capabilities: {
          tools: ['hello-world', 'get-current-time', 'random-number'],
          resources: ['greeting-templates', 'system-info'],
          prompts: ['code-review', 'explain-concept']
        }
      };

      const data = category && systemInfo[category as keyof typeof systemInfo] 
        ? systemInfo[category as keyof typeof systemInfo]
        : systemInfo;

      return {
        contents: [
          {
            uri: uri.href,
            mimeType: "application/json", 
            text: JSON.stringify(data, null, 2)
          }
        ]
      };
    }
  );
}
5. Creating Prompts (src/prompts.ts)
Prompts are reusable templates that help AI agents:

typescript

Copy
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

export function setupServerPrompts(server: McpServer) {
  // Code review prompt
  server.prompt(
    'code-review',
    'Generate a thorough code review',
    (args) => ({
      messages: [
        {
          role: 'user',
          content: {
            type: 'text',
            text: `Please review this code and provide feedback:

${args?.code || '[No code provided]'}

Focus on:
- Code quality and best practices
- Security considerations  
- Performance optimizations
- Maintainability improvements

Language: ${args?.language || 'Unknown'}`
          }
        }
      ]
    })
  );

  // Concept explanation prompt
  server.prompt(
    'explain-concept',
    'Explain a concept clearly and simply',
    (args) => ({
      messages: [
        {
          role: 'user', 
          content: {
            type: 'text',
            text: `Please explain "${args?.concept || '[No concept provided]'}" in simple terms.

Target audience: ${args?.audience || 'General audience'}
Detail level: ${args?.level || 'Beginner'}

Include:
- Clear definition
- Real-world examples
- Common misconceptions (if any)
- Why it matters`
          }
        }
      ]
    })
  );
}
Test locally
run pnpm run dev
Go to the http://localhost:6724 and enter in the mcp server http://localhost:8787/sse and start testing with MCP Inspector
Deployment to Production
1. Deploy to Cloudflare
bash

Copy
# Deploy your MCP server
npx wrangler deploy
2. Use Your MCP Server
Once deployed, your MCP server will be available at:

WebSocket: wss://your-worker.workers.dev/ws
SSE: https://your-worker.workers.dev/sse
Next Steps
Expand Your Server
Add More Tools: Create tools for file operations, API integrations, calculations
Dynamic Resources: Connect to databases, APIs, or file systems
Advanced Prompts: Create domain-specific prompt templates
Error Handling: Implement robust error handling and retries
Integration Examples
typescript

Copy
// File system tool
server.tool('read-file', 'Read file contents', {
  path: z.string().describe('File path to read')
}, async ({ path }) => {
  const content = await Deno.readTextFile(path);
  return { content: [{ type: "text", text: content }] };
});

// API integration tool  
server.tool('weather', 'Get weather information', {
  location: z.string().describe('City name or coordinates')
}, async ({ location }) => {
  const weather = await fetch(`https://api.weather.com/v1/current?location=${location}`);
  const data = await weather.json();
  return { content: [{ type: "text", text: JSON.stringify(data) }] };
});
Advanced Patterns
Stateful Tools: Use Durable Objects for persistent state
Streaming Tools: Implement real-time data streams
Composite Tools: Chain multiple operations together
Authenticated Tools: Add authentication and authorization
Resources
MCP Template Repository - Complete source code
MCP Integration Testing - Comprehensive testing guide with utilities
MCP Specification - Official protocol documentation
Agent Framework - Integrate with AI agents
Platform Services - Backend services for MCP servers
üéâ Congratulations! You've built your first MCP server. Your tools are now ready to be used by AI agents across any platform that supports the Model Context Protocol.


TODO List Example
Ready to see MCP in action? This example showcases a complete TODO management system built with our TypeScript MCP Framework. You'll see full CRUD operations, type-safe schemas, and production-ready patterns in just a few files.

What You'll Build
A fully functional TODO MCP server with:

‚úÖ Create - Add new tasks with validation
üìñ Read - List and search todos
‚úèÔ∏è Update - Modify existing tasks
üóëÔ∏è Delete - Remove completed tasks
üîç Smart Filtering - By status, priority, and date
üìä Rich Resources - Data access for AI agents
Architecture Overview
code

Copy
todo-mcp-server/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Entry point & routing
‚îÇ   ‚îú‚îÄ‚îÄ server.ts      # MCP server configuration  
‚îÇ   ‚îú‚îÄ‚îÄ tools.ts       # CRUD tool implementations
‚îÇ   ‚îú‚îÄ‚îÄ resources.ts   # Data resources for agents
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts      # Zod schemas & validation
‚îÇ   ‚îî‚îÄ‚îÄ repository.ts  # Data persistence layer
The architecture follows clean separation of concerns with type-safe interfaces throughout.

Key Implementation Patterns
1. Type-Safe Schemas (schema.ts)
Clean data models with full validation:

typescript

Copy
import { z } from 'zod';

export const TodoSchema = z.object({
  id: z.string().uuid(),
  title: z.string().min(1).max(200),
  description: z.string().optional(),
  completed: z.boolean().default(false),
  priority: z.enum(['low', 'medium', 'high']).default('medium'),
  dueDate: z.string().datetime().optional(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
});

export type Todo = z.infer<typeof TodoSchema>;
2. CRUD Tools (tools.ts)
Complete set of operations with error handling:

typescript

Copy
export function setupTodoTools(server: McpServer) {
  // CREATE Todo
  server.tool(
    'createTodo',
    'Create a new todo item',
    {
      title: z.string().describe('Todo title'),
      description: z.string().optional().describe('Optional description'),
      priority: z.enum(['low', 'medium', 'high']).optional(),
      dueDate: z.string().datetime().optional()
    },
    async ({ title, description, priority, dueDate }) => {
      const todo = await todoRepository.create({
        title, description, priority, dueDate
      });
      
      return {
        content: [{
          type: "text",
          text: JSON.stringify({ success: true, todo })
        }]
      };
    }
  );

  // READ Todos with filtering
  server.tool(
    'listTodos',
    'List todos with optional filtering',
    {
      completed: z.boolean().optional(),
      priority: z.enum(['low', 'medium', 'high']).optional()
    },
    async ({ completed, priority }) => {
      const todos = await todoRepository.findAll({ completed, priority });
      return {
        content: [{
          type: "text", 
          text: JSON.stringify({ success: true, todos })
        }]
      };
    }
  );
}
3. SQL Database & Repository (repository.ts)
Powered by Durable Object SQLite storage - This example uses agent local SQL storage for zero-latency data access and immediate consistency.

Why Durable Object Storage?
‚úÖ Zero Network Latency - Sub-millisecond data access
‚úÖ No Additional Costs - Included in Durable Object pricing
‚úÖ Immediate Consistency - No replication lag
‚úÖ ACID Compliance - Full transaction support
‚úÖ Perfect for Agent State - Isolated, persistent storage per agent

SQL Schema Definition
From the TypeScript Agent Framework schema:

typescript

Copy
// SQL table schema
const TODO_TABLE_SCHEMA = `
  CREATE TABLE IF NOT EXISTS todos (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    completed BOOLEAN DEFAULT 0,
    priority TEXT DEFAULT 'medium',
    due_date TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
  );
  
  CREATE INDEX IF NOT EXISTS idx_todos_completed ON todos(completed);
  CREATE INDEX IF NOT EXISTS idx_todos_priority ON todos(priority);
  CREATE INDEX IF NOT EXISTS idx_todos_due_date ON todos(due_date);
`;
Repository Implementation
Clean data layer with SQL persistence:

typescript

Copy
export class TodoRepository {
  constructor(private storage: SqlStorage) {
    this.initializeDatabase();
  }

  private async initializeDatabase() {
    // Apply SQL schema on startup
    await this.storage.exec(TODO_TABLE_SCHEMA);
  }

  async create(data: Omit<Todo, 'id' | 'createdAt' | 'updatedAt'>): Promise<Todo> {
    const todo: Todo = {
      id: crypto.randomUUID(),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      completed: false,
      priority: 'medium',
      ...data
    };

    await this.storage
      .prepare(`
        INSERT INTO todos (id, title, description, completed, priority, due_date, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `)
      .bind(
        todo.id, todo.title, todo.description, 
        todo.completed ? 1 : 0, todo.priority, 
        todo.dueDate, todo.createdAt, todo.updatedAt
      )
      .run();

    return todo;
  }

  async findAll(filters?: { completed?: boolean; priority?: string }): Promise<Todo[]> {
    let sql = 'SELECT * FROM todos WHERE 1=1';
    const params: any[] = [];
    
    if (filters?.completed !== undefined) {
      sql += ' AND completed = ?';
      params.push(filters.completed ? 1 : 0);
    }
    
    if (filters?.priority) {
      sql += ' AND priority = ?';
      params.push(filters.priority);
    }
    
    sql += ' ORDER BY created_at DESC';
    
    const result = await this.storage
      .prepare(sql)
      .bind(...params)
      .all();

    return result.map(this.mapRowToTodo);
  }

  private mapRowToTodo(row: any): Todo {
    return {
      id: row.id,
      title: row.title,
      description: row.description,
      completed: Boolean(row.completed),
      priority: row.priority,
      dueDate: row.due_date,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };
  }
}
Key Benefits: The repository pattern abstracts SQL complexity while leveraging the powerful SQL storage capabilities built into our platform.

4. Smart Resources (resources.ts)
Rich data access for AI agents:

typescript

Copy
export function setupTodoResources(server: McpServer) {
  // Live todo statistics
  server.resource(
    'todo-stats',
    'resource://todo-stats',
    async () => {
      const todos = await todoRepository.findAll();
      const stats = {
        total: todos.length,
        completed: todos.filter(t => t.completed).length,
        byPriority: {
          high: todos.filter(t => t.priority === 'high').length,
          medium: todos.filter(t => t.priority === 'medium').length,
          low: todos.filter(t => t.priority === 'low').length
        }
      };

      return {
        contents: [{
          uri: 'resource://todo-stats',
          mimeType: 'application/json',
          text: JSON.stringify(stats, null, 2)
        }]
      };
    }
  );
}
5. Server Configuration (server.ts)
Bringing it all together:

typescript

Copy
import { McpHonoServerDO } from "@nullshot/mcp-framework";
import { setupTodoTools } from "./tools";
import { setupTodoResources } from "./resources";

export class TodoMCPServer extends McpHonoServerDO<Env> {
  getImplementation(): Implementation {
    return {
      name: 'TodoMCPServer',
      version: '1.0.0',
    };
  }

  configureServer(server: McpServer): void {
    setupTodoTools(server);
    setupTodoResources(server);
  }
}
Why This Pattern Works
üõ°Ô∏è Type Safety - Zod schemas ensure data integrity at runtime
üß© Modular Design - Each concern is cleanly separated
üöÄ AI-Ready - Resources provide rich context for agents
üîß Extensible - Easy to add new operations and filters
‚úÖ Production Ready - Error handling and validation built-in

Test It Out
bash

Copy
# Clone the example
git clone https://github.com/null-shot/typescript-agent-framework
cd examples/crud-mcp

# Install & run
pnpm install
pnpm dev

# Test in MCP Inspector at http://localhost:6274
What Makes This Special
This isn't just another CRUD example. It demonstrates:

Schema-First Design - Types drive everything
Agent-Friendly Resources - AI can understand your data
Real Error Handling - Production-grade validation
Clean Architecture - Maintainable and extensible
Next Steps
Ready to build your own? Check out:

Complete Source Code - Full implementation with tests
Getting Started Guide - Build from scratch
Integration Testing - Test your CRUD operations
Agent Framework - Connect to AI agents
üéØ Ready to build? This TODO example shows how clean architecture and MCP make building AI-ready tools a breeze. Start with the complete source and adapt it to your needs!

Integration Testing
Testing MCP servers requires specialized approaches due to the unique challenges of the Cloudflare Workers environment and the Model Context Protocol's real-time communication patterns. This guide covers comprehensive testing strategies, utilities, and real-world examples.

Why Specialized Testing is Needed
MCP servers running on Cloudflare Workers face unique testing challenges:

No Native Node.js Features: Standard libraries like native fetch aren't available
WebSocket & SSE Communication: Requires specialized transports for testing
Durable Objects State: Stateful testing across multiple requests
Real-time Protocols: Async communication patterns need careful testing
Testing Utilities Overview
Our platform provides specialized testing utilities specifically designed for Cloudflare Workers MCP servers:

Core Testing Transports
WorkerSSEClientTransport - Server-Sent Events testing transport

Handles SSE communication patterns in Cloudflare Workers
Mock-friendly for unit testing
Supports streaming responses
WorkerWebSocketClientTransport - WebSocket testing transport

Full WebSocket protocol support for Workers environment
Bidirectional communication testing
Connection lifecycle management
These utilities are essential because Cloudflare's environment doesn't support standard Node.js features, requiring specialized implementations for testing.

Testing Architecture
1. Unit Testing MCP Tools
Test individual MCP tools in isolation:

typescript

Copy
import { describe, it, expect, beforeEach } from 'vitest';
import { TodoMCPServer } from '../src/todo-mcp-server';
import { WorkerSSEClientTransport } from '@nullshot/test-utils';

describe('Todo MCP Tools', () => {
  let server: TodoMCPServer;
  let transport: WorkerSSEClientTransport;

  beforeEach(async () => {
    server = new TodoMCPServer();
    transport = new WorkerSSEClientTransport({
      serverUrl: 'http://localhost:8787/sse'
    });
    await transport.connect();
  });

  it('should create a new todo item', async () => {
    const result = await transport.callTool('create-todo', {
      title: 'Test Task',
      description: 'Test Description',
      priority: 'high'
    });

    expect(result.success).toBe(true);
    expect(result.data.title).toBe('Test Task');
    expect(result.data.id).toBeDefined();
  });

  it('should list all todos', async () => {
    // Create test data
    await transport.callTool('create-todo', {
      title: 'Task 1',
      description: 'First task'
    });
    
    await transport.callTool('create-todo', {
      title: 'Task 2', 
      description: 'Second task'
    });

    const result = await transport.callTool('list-todos', {});
    
    expect(result.success).toBe(true);
    expect(result.data.todos).toHaveLength(2);
    expect(result.data.todos[0].title).toBe('Task 1');
  });

  it('should handle invalid tool parameters', async () => {
    const result = await transport.callTool('create-todo', {
      // Missing required title parameter
      description: 'Test Description'
    });

    expect(result.success).toBe(false);
    expect(result.error).toContain('Missing required parameter: title');
  });
});
2. Integration Testing with WebSocket
Test real-time communication patterns:

typescript

Copy
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { WorkerWebSocketClientTransport } from '@nullshot/test-utils';
import { MCPClient } from '@modelcontextprotocol/sdk/client/index.js';

describe('Todo MCP WebSocket Integration', () => {
  let client: MCPClient;
  let transport: WorkerWebSocketClientTransport;

  beforeEach(async () => {
    transport = new WorkerWebSocketClientTransport({
      serverUrl: 'ws://localhost:8787/ws'
    });
    
    client = new MCPClient(
      {
        name: 'test-client',
        version: '1.0.0'
      },
      {
        capabilities: {
          tools: {}
        }
      }
    );

    await client.connect(transport);
  });

  afterEach(async () => {
    await client.close();
  });

  it('should establish WebSocket connection and list tools', async () => {
    const tools = await client.listTools();
    
    expect(tools.tools).toBeDefined();
    expect(tools.tools.length).toBeGreaterThan(0);
    
    const todoTools = tools.tools.filter(tool => 
      tool.name.startsWith('todo-')
    );
    expect(todoTools.length).toBeGreaterThan(0);
  });

  it('should handle tool calls over WebSocket', async () => {
    const result = await client.callTool({
      name: 'create-todo',
      arguments: {
        title: 'WebSocket Test Task',
        description: 'Created via WebSocket'
      }
    });

    expect(result.content).toBeDefined();
    expect(result.content[0].type).toBe('text');
    
    const response = JSON.parse(result.content[0].text);
    expect(response.success).toBe(true);
    expect(response.data.title).toBe('WebSocket Test Task');
  });
});
Real-World Testing Examples
Based on the comprehensive test suite from the TypeScript Agent Framework, here are production-ready testing patterns:

Complete CRUD Testing
typescript

Copy
describe('Todo CRUD Operations', () => {
  let client: MCPClient;
  let transport: WorkerWebSocketClientTransport;

  beforeEach(async () => {
    transport = new WorkerWebSocketClientTransport({
      serverUrl: 'ws://localhost:8787/ws'
    });
    
    client = new MCPClient({
      name: 'crud-test-client',
      version: '1.0.0'
    }, {
      capabilities: { tools: {} }
    });

    await client.connect(transport);
  });

  afterEach(async () => {
    await client.close();
  });

  it('should perform complete CRUD lifecycle', async () => {
    // CREATE
    const createResult = await client.callTool({
      name: 'createTodo',
      arguments: {
        title: 'Integration Test Todo',
        description: 'Testing full CRUD cycle',
        priority: 'high',
        dueDate: '2024-12-31'
      }
    });

    const createdTodo = JSON.parse(createResult.content[0].text);
    expect(createdTodo.success).toBe(true);
    expect(createdTodo.todo.id).toBeDefined();
    
    const todoId = createdTodo.todo.id;

    // READ
    const readResult = await client.callTool({
      name: 'getTodo',
      arguments: { id: todoId }
    });

    const retrievedTodo = JSON.parse(readResult.content[0].text);
    expect(retrievedTodo.success).toBe(true);
    expect(retrievedTodo.todo.title).toBe('Integration Test Todo');

    // UPDATE
    const updateResult = await client.callTool({
      name: 'updateTodo',
      arguments: {
        id: todoId,
        title: 'Updated Test Todo',
        completed: true
      }
    });

    const updatedTodo = JSON.parse(updateResult.content[0].text);
    expect(updatedTodo.success).toBe(true);
    expect(updatedTodo.todo.title).toBe('Updated Test Todo');
    expect(updatedTodo.todo.completed).toBe(true);

    // DELETE
    const deleteResult = await client.callTool({
      name: 'deleteTodo',
      arguments: { id: todoId }
    });

    const deleteResponse = JSON.parse(deleteResult.content[0].text);
    expect(deleteResponse.success).toBe(true);

    // VERIFY DELETION
    const verifyResult = await client.callTool({
      name: 'getTodo',
      arguments: { id: todoId }
    });

    const verifyResponse = JSON.parse(verifyResult.content[0].text);
    expect(verifyResponse.success).toBe(false);
    expect(verifyResponse.error).toContain('not found');
  });
});
Error Handling and Edge Cases
typescript

Copy
describe('Todo Error Handling', () => {
  let client: MCPClient;

  beforeEach(async () => {
    const transport = new WorkerWebSocketClientTransport({
      serverUrl: 'ws://localhost:8787/ws'
    });
    client = new MCPClient({
      name: 'error-test-client',
      version: '1.0.0'
    }, { capabilities: { tools: {} } });
    await client.connect(transport);
  });

  it('should handle validation errors gracefully', async () => {
    const result = await client.callTool({
      name: 'createTodo',
      arguments: {
        // Missing required title
        description: 'Todo without title',
        priority: 'invalid-priority' // Invalid enum
      }
    });

    const response = JSON.parse(result.content[0].text);
    expect(response.success).toBe(false);
    expect(response.error).toContain('validation failed');
    expect(response.details).toBeDefined();
  });

  it('should handle resource not found errors', async () => {
    const result = await client.callTool({
      name: 'getTodo',
      arguments: { id: 'nonexistent-id' }
    });

    const response = JSON.parse(result.content[0].text);
    expect(response.success).toBe(false);
    expect(response.error).toContain('Todo not found');
  });

  it('should handle malformed requests', async () => {
    try {
      await client.callTool({
        name: 'createTodo',
        arguments: 'invalid-json-string' // Should be object
      });
      expect.fail('Should have thrown validation error');
    } catch (error) {
      expect(error.message).toContain('Invalid arguments');
    }
  });
});
Testing Utilities Reference
WorkerSSEClientTransport Usage
The SSE transport is ideal for testing streaming responses and server-sent events:

typescript

Copy
import { WorkerSSEClientTransport } from '@nullshot/test-utils';

const transport = new WorkerSSEClientTransport({
  serverUrl: 'http://localhost:8787/sse',
  headers: {
    'Authorization': 'Bearer test-token',
    'X-Test-Session': 'integration-test'
  },
  timeout: 30000
});

// Handle streaming data
transport.onMessage((data) => {
  console.log('Received streaming data:', data);
});

await transport.connect();
WorkerWebSocketClientTransport Usage
The WebSocket transport handles bidirectional real-time communication:

typescript

Copy
import { WorkerWebSocketClientTransport } from '@nullshot/test-utils';

const transport = new WorkerWebSocketClientTransport({
  serverUrl: 'ws://localhost:8787/ws',
  protocols: ['mcp'],
  reconnectAttempts: 3,
  reconnectDelay: 1000
});

// Handle connection events
transport.onConnect(() => {
  console.log('WebSocket connected');
});

transport.onDisconnect(() => {
  console.log('WebSocket disconnected');
});

transport.onError((error) => {
  console.error('WebSocket error:', error);
});

await transport.connect();
Performance and Load Testing
Concurrent Client Testing
typescript

Copy
describe('MCP Server Load Testing', () => {
  it('should handle multiple concurrent clients', async () => {
    const clientCount = 20;
    const clients: MCPClient[] = [];

    // Create multiple clients
    for (let i = 0; i < clientCount; i++) {
      const transport = new WorkerWebSocketClientTransport({
        serverUrl: 'ws://localhost:8787/ws',
        sessionId: `load-test-${i}`
      });

      const client = new MCPClient({
        name: `load-test-client-${i}`,
        version: '1.0.0'
      }, { capabilities: { tools: {} } });

      await client.connect(transport);
      clients.push(client);
    }

    // Perform concurrent operations
    const operations = clients.map((client, index) => 
      client.callTool({
        name: 'createTodo',
        arguments: {
          title: `Concurrent Todo ${index}`,
          description: `Created by client ${index}`
        }
      })
    );

    const results = await Promise.all(operations);
    
    // Verify all operations succeeded
    results.forEach((result, index) => {
      const response = JSON.parse(result.content[0].text);
      expect(response.success).toBe(true);
      expect(response.todo.title).toBe(`Concurrent Todo ${index}`);
    });

    // Cleanup
    await Promise.all(clients.map(client => client.close()));
  }, 60000); // Extended timeout for load test
});
Test Configuration
Vitest Configuration for MCP Servers
Based on the TypeScript Agent Framework CRUD MCP example, here's the complete Vitest configuration optimized for MCP server testing:

typescript

Copy
// vitest.config.ts
import { defineWorkersConfig } from "@cloudflare/vitest-pool-workers/config";

export default defineWorkersConfig({
  test: {
    globals: true,
    environment: "miniflare",
    // Configure timeouts for MCP operations
    testTimeout: 10000,
    hookTimeout: 10000,
    teardownTimeout: 5000,
    
    poolOptions: {
      workers: {
        wrangler: { 
          configPath: "./wrangler.toml" 
        },
        miniflare: {
          // Enable compatibility date for latest features
          compatibilityDate: "2024-03-01",
          compatibilityFlags: ["nodejs_compat"],
          
          // Configure bindings for testing
          bindings: {
            NODE_ENV: "test"
          },
          
          // Durable Objects configuration for MCP servers
          durableObjects: {
            "MCP_SERVER": "McpServerDO"
          },
          
          // Enable live reload for faster development
          liveReload: true,
          
          // Configure KV storage for tests (if needed)
          kvNamespaces: ["TEST_NAMESPACE"],
          
          // Configure D1 databases for tests (if needed)
          d1Databases: ["TEST_DB"]
        }
      }
    }
  }
});
Essential Dependencies
Install the required testing dependencies for Cloudflare Workers MCP testing:

bash

Copy
# Core testing framework
pnpm add -D vitest@~3.1.0

# Cloudflare Workers Vitest integration
pnpm add -D @cloudflare/vitest-pool-workers

# TypeScript Agent Framework testing utilities
pnpm add -D @nullshot/test-utils

# Additional testing utilities (optional)
pnpm add -D @vitest/ui      # For visual test debugging
pnpm add -D @vitest/coverage-v8  # For coverage reporting
TypeScript Configuration
Configure TypeScript for testing with proper type definitions:

typescript

Copy
// test/tsconfig.json
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "moduleResolution": "bundler",
    "types": [
      "@cloudflare/vitest-pool-workers",
      "@nullshot/test-utils",
      "vitest/globals"
    ]
  },
  "include": [
    "./**/*.ts",
    "../src/**/*.ts",
    "../src/env.d.ts"  // Include generated environment types
  ]
}
typescript

Copy
// test/env.d.ts
declare module "cloudflare:test" {
  interface ProvidedEnv extends Env {
    NODE_ENV: "test";
    // Add any additional test-specific environment variables
  }
}
Testing Best Practices
1. Test Environment Setup
Create a dedicated test setup that follows Cloudflare Workers best practices:

typescript

Copy
// test/setup.ts
import { beforeAll, afterAll, beforeEach } from 'vitest';
import { env, SELF } from 'cloudflare:test';

// Global test configuration
beforeAll(async () => {
  // Set test environment
  console.log('üß™ Setting up MCP test environment...');
  
  // Wait for MCP server to be ready
  const healthCheck = await SELF.fetch('/health');
  if (!healthCheck.ok) {
    throw new Error('MCP server failed health check');
  }
  
  console.log('‚úÖ MCP server ready for testing');
});

// Clean state between tests
beforeEach(async () => {
  // Clear any test data between tests
  if (env.TEST_NAMESPACE) {
    // Clear KV data if using KV storage
    const keys = await env.TEST_NAMESPACE.list();
    await Promise.all(
      keys.keys.map(key => env.TEST_NAMESPACE.delete(key.name))
    );
  }
});

afterAll(() => {
  console.log('üßπ Test cleanup completed');
});
2. Data Isolation
Ensure tests don't interfere with each other:

typescript

Copy
describe('Todo Tests with Clean State', () => {
  beforeEach(async () => {
    // Clear all test data before each test
    const transport = new WorkerWebSocketClientTransport({
      serverUrl: 'ws://localhost:8787/ws'
    });
    const client = new MCPClient({
      name: 'cleanup-client',
      version: '1.0.0'
    }, { capabilities: { tools: {} } });
    
    await client.connect(transport);
    await client.callTool({
      name: 'clearAllTodos',
      arguments: {}
    });
    await client.close();
  });
});
3. Mock External Dependencies
typescript

Copy
// Mock external services during testing
vi.mock('@external/notification-service', () => ({
  sendNotification: vi.fn().mockResolvedValue({ sent: true }),
  validateApiKey: vi.fn().mockReturnValue(true)
}));
2. Wrangler Configuration for Testing
Configure your wrangler.toml to support testing with proper environment separation:

toml

Copy
# wrangler.toml
name = "my-mcp-server"
main = "src/index.ts"
compatibility_date = "2024-03-01"
compatibility_flags = ["nodejs_compat"]

[
env.test
]
name = "my-mcp-server-test"
account_id = "your-test-account-id"

# Durable Objects configuration for MCP server
[[
durable_objects.bindings
]]
name = "MCP_SERVER"
class_name = "McpServerDO"

# Test environment variables
[
env.test.vars
]
NODE_ENV = "test"
LOG_LEVEL = "debug"

# Test KV namespaces (if needed)
[[
env.test.kv_namespaces
]]
binding = "TEST_NAMESPACE"
id = "test-namespace-id"

# Test D1 databases (if needed)
[[
env.test.d1_databases
]]
binding = "TEST_DB"
database_name = "test-database"
database_id = "test-database-id"
3. Advanced Testing Patterns
Testing MCP Tool Registration
typescript

Copy
// test/mcp-registration.test.ts
import { describe, it, expect } from 'vitest';
import { env, SELF } from 'cloudflare:test';

describe('MCP Tool Registration', () => {
  it('should register all required MCP tools', async () => {
    const response = await SELF.fetch('/mcp/tools', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 1,
        method: 'tools/list'
      })
    });

    const result = await response.json();
    expect(result.result.tools).toBeDefined();
    
    const toolNames = result.result.tools.map(tool => tool.name);
    expect(toolNames).toContain('create-todo');
    expect(toolNames).toContain('list-todos');
    expect(toolNames).toContain('update-todo');
    expect(toolNames).toContain('delete-todo');
  });

  it('should validate tool schemas correctly', async () => {
    const response = await SELF.fetch('/mcp/tools/create-todo', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 1,
        method: 'tools/call',
        params: {
          name: 'create-todo',
          arguments: {
            title: 'Test Todo',
            description: 'A test todo item'
          }
        }
      })
    });

    const result = await response.json();
    expect(result.result).toBeDefined();
    expect(result.error).toBeUndefined();
  });
});
Testing Durable Objects State
typescript

Copy
// test/durable-objects.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { env, runInDurableObject } from 'cloudflare:test';

describe('MCP Server Durable Object', () => {
  let mcpServerStub: DurableObjectStub;

  beforeEach(() => {
    const id = env.MCP_SERVER.newUniqueId();
    mcpServerStub = env.MCP_SERVER.get(id);
  });

  it('should maintain state across requests', async () => {
    // Create a todo via the Durable Object
    const createResponse = await mcpServerStub.fetch('/todos', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        title: 'Persistent Todo',
        description: 'This should persist'
      })
    });

    const createdTodo = await createResponse.json();
    expect(createdTodo.id).toBeDefined();

    // Retrieve the todo to verify persistence
    const getResponse = await mcpServerStub.fetch(`/todos/${createdTodo.id}`);
    const retrievedTodo = await getResponse.json();
    
    expect(retrievedTodo.title).toBe('Persistent Todo');
    expect(retrievedTodo.description).toBe('This should persist');
  });

  it('should handle concurrent operations safely', async () => {
    // Test concurrent creates
    const promises = Array(5).fill(0).map((_, i) => 
      mcpServerStub.fetch('/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: `Concurrent Todo ${i}`,
          description: `Created concurrently ${i}`
        })
      })
    );

    const responses = await Promise.all(promises);
    const todos = await Promise.all(
      responses.map(response => response.json())
    );

    // All todos should be created successfully
    todos.forEach((todo, i) => {
      expect(todo.title).toBe(`Concurrent Todo ${i}`);
      expect(todo.id).toBeDefined();
    });

    // Verify all todos are stored
    const listResponse = await mcpServerStub.fetch('/todos');
    const allTodos = await listResponse.json();
    expect(allTodos.length).toBe(5);
  });
});
Running the Test Suite
bash

Copy
# Run all tests
pnpm test

# Run tests with UI for visual debugging
pnpm test:ui

# Run specific test files
pnpm test todo-crud
pnpm test mcp-registration

# Run tests with coverage
pnpm test:coverage

# Run tests in watch mode for development
pnpm test:watch

# Run only integration tests
pnpm test:integration

# Run performance tests
pnpm test:perf
Package.json Scripts
Add these testing scripts to your package.json:

json

Copy
{
  "scripts": {
    "test": "vitest run",
    "test:ui": "vitest --ui",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "test:integration": "vitest run test/integration",
    "test:perf": "vitest run test/performance",
    "test:setup": "wrangler d1 create test-database"
  }
}
Resources
TypeScript Agent Framework Test Utils - Essential testing utilities for Cloudflare Workers
Complete Test Examples - Real-world MCP testing patterns
MCP Inspector - Visual testing interface
Vitest Documentation - Modern testing framework
üß™ Ready to test! With these specialized utilities and comprehensive examples, you can build robust test suites that ensure your MCP servers work correctly in the Cloudflare Workers environment.